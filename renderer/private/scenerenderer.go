package private

import (
	"fmt"
	"log"
	"reflect"
	"time"

	"github.com/CrimsonAS/goggle/sg"
	"github.com/CrimsonAS/goggle/sg/components"
	"github.com/CrimsonAS/goggle/sg/layouts"
	"github.com/CrimsonAS/goggle/sg/nodes"
)

const sceneDebug = false

// DrawableNode contains a primitive node type that is directly drawable by a
// backend, fully resolved and processed in the scenegraph.
type DrawableNode struct {
	// Node is a drawable primitive node from the scene. The node is not
	// automatically copied, so this reference is not safe to keep after the
	// rendering functions return to user code unless explicitly deep copied.
	Node      sg.Node
	Transform nodes.Transform
}

// shadowNode is an entry in the shadow tree, generated by SceneRenderer during
// passes over the node tree. The shadow tree has a node for every node in the input
// scene, including rendered trees. The exact structure of the tree may differ slightly.
type shadowNode struct {
	// Original node from the input scene
	sceneNode sg.Node
	// Resolved result of calling Render() on sceneNode, if the sceneNode is a Component
	rendered *shadowNode
	// Resolved children of the node, if the sceneNode is Parentable. When a Component
	// returns a non-nil render tree, children of the node will appear under the rendered node
	// instead.
	shadowChildren []*shadowNode
	// Persisted state for the node
	state components.StateType
	// Accumulated transform for this node
	transform sg.Mat4
}

type SceneRenderer struct {
	Window          sg.Windowable
	InputHelper     *InputHelper
	FullSecondPass  bool
	resolveDrawable bool
	resolveInputs   bool

	shadowRoot *shadowNode
}

func (r *SceneRenderer) Render(root sg.Node) {
	var tmStart, tmPass time.Time
	var dResolve, dEvents, dCompile time.Duration

	// The root of the tree for SceneRenderer must be a Box, defining the
	// constraints for the scene. Generally, this will be provided by the
	// window backend when calling Render.
	_ = root.(layouts.Box)

	// Resolve tree
	r.resolveDrawable = true
	r.resolveInputs = true
	if sceneDebug {
		tmStart = time.Now()
		tmPass = tmStart
		log.Printf("scene: (1/3) resolving tree")
	}
	newShadowRoot := &shadowNode{sceneNode: root, transform: sg.NewIdentity()}

	const resolveDebug = false // extremely noisy

	if resolveDebug {
		log.Printf("PRE-RENDER, tree is: %+v", r.shadowRoot)
	}

	r.resolveBox(newShadowRoot, r.shadowRoot, sg.Unconstrained())
	r.shadowRoot = newShadowRoot

	if resolveDebug {
		log.Printf("POST-RENDER, tree is: %+v", r.shadowRoot)
	}

	if sceneDebug {
		now := time.Now()
		dCompile = now.Sub(tmPass)
		dTotal := now.Sub(tmStart)
		log.Printf("scene: resolved in %s (resolve/events/compile: %s/%s/%s)", dTotal, dResolve, dEvents, dCompile)
	}
}

func (r *SceneRenderer) walkTree(shadow *shadowNode, backwards bool, geo sg.Geometry, callback func(*shadowNode, sg.Geometry)) {
	if shadow == nil {
		return
	}

	if _, ok := shadow.sceneNode.(layouts.Box); ok {
		boxState, _ := shadow.state.(renderBoxState)
		geo = geo.Translate(boxState.Pos.X, boxState.Pos.Y)
		geo.Width, geo.Height = boxState.Size.Width, boxState.Size.Height
	}

	if !backwards {
		callback(shadow, geo)
		if shadow.rendered != nil {
			r.walkTree(shadow.rendered, backwards, geo, callback)
		}
	}

	for i := 0; i < len(shadow.shadowChildren); i++ {
		var child *shadowNode
		if backwards {
			child = shadow.shadowChildren[len(shadow.shadowChildren)-i-1]
		} else {
			child = shadow.shadowChildren[i]
		}
		r.walkTree(child, backwards, geo, callback)
	}

	if backwards {
		if shadow.rendered != nil {
			r.walkTree(shadow.rendered, backwards, geo, callback)
		}
		callback(shadow, geo)
	}
}

// DeliverEvents walks the rendered shadow tree in input order and
// invokes callbacks or updates state in the tree as appropriate.
// DeliverEvents changes state but does not re-render the tree, so
// the shadow tree is considered dirty after calling this function.
func (r *SceneRenderer) DeliverEvents() {
	r.walkTree(r.shadowRoot, true, sg.Geometry{}, func(shadow *shadowNode, geo sg.Geometry) {
		if node, ok := shadow.sceneNode.(nodes.Input); ok {
			state, _ := shadow.state.(*nodes.InputState)
			if state == nil {
				state = &nodes.InputState{}
				shadow.state = state
			}
			r.InputHelper.ProcessPointerEvents(&node, shadow.transform, node.Size, state)
		}
	})
	r.InputHelper.EndPointerEvents()
}

// Draw walks the rendered shadow tree in draw order and calls the
// nodeCallback function for each primitive node.
func (r *SceneRenderer) Draw(nodeCallback func(sg.Node, sg.Geometry, sg.Mat4)) {
	r.walkTree(r.shadowRoot, false, sg.Geometry{}, func(shadow *shadowNode, geo sg.Geometry) {
		switch node := shadow.sceneNode.(type) {
		case nodes.Rectangle:
			nodeCallback(node, geo, shadow.transform)
		case nodes.Image:
			nodeCallback(node, geo, shadow.transform)
		}
	})
}

// resolveNode populates a shadowNode by resolving the sceneNode it represents.
// When an oldShadow is also provided, the new tree is correlated with the old
// tree to preserve node state.
//
// resolveNode expects a shadowNode with sceneNode and transform defined,
// and all other fields to have the default value.
//
// resolveNode does not populate the list of child nodes, and does not resolve
// the rendered tree.
//
// Returns true if the node is resolved, or false if the node is unresolvable
// for any reason. These may include errors, unrecognized nodes, or nodes that
// need to be resolved in a different way (e.g. Box).
func (r *SceneRenderer) resolveNode(shadow *shadowNode, oldShadow *shadowNode) bool {
	node := shadow.sceneNode

	// If the node's actual type is the same as the old tree, we need to preserve state.
	// For any node where we're not preserving state, oldShadow is discarded here.
	if oldShadow != nil && reflect.TypeOf(oldShadow.sceneNode) != reflect.TypeOf(shadow.sceneNode) {
		if sceneDebug {
			log.Printf("Node type changed from '%T' to '%T', discarding subtree state", oldShadow.sceneNode, shadow.sceneNode)
		}
		oldShadow = nil
	}

	// Copy state from the old shadow tree
	if oldShadow != nil {
		shadow.state = oldShadow.state
	}

	switch n := node.(type) {
	case components.Component:
		// Render node
		state := components.RenderState{
			Window:    r.Window,
			NodeState: shadow.state,
			Transform: shadow.transform,
		}
		renderedNode := n.Type(n.Props, &state)
		shadow.state, shadow.transform = state.NodeState, state.Transform

		if renderedNode != nil {
			shadow.rendered = &shadowNode{sceneNode: renderedNode, transform: shadow.transform}
		}

	case nodes.Transform:
		shadow.transform = shadow.transform.MulM4(n.Matrix)

	case nodes.Rectangle:
	case nodes.Image:
	case nodes.Input:

	// Box layouts are handled by the parent Box, not by resolveNode.
	case layouts.Box:
		return false
	default:
		return false
	}

	return true
}

type shadowNodePairs []struct{ Current, Old *shadowNode }

// resolveTree recursively resolves the node in 'shadow', its rendered tree, and
// its children. If oldShadow is provided, state will be preserved from that tree.
//
// resolveTree returns a list of nodes at any level of the tree which could not
// be resolved. Some of these may indicate errors, but the common case is to return
// a list of Box nodes in need of layout.
func (r *SceneRenderer) resolveTree(shadow *shadowNode, oldShadow *shadowNode) shadowNodePairs {
	// Resolve this node
	if !r.resolveNode(shadow, oldShadow) {
		// Node is unresolvable; return it to build the list of unresolvable nodes.
		//
		// There is no need to keep oldShadow for this list. If there is state to
		// preserve on this node, resolveNode has already done so.
		return shadowNodePairs{{shadow, oldShadow}}
	}

	return r.resolveTreeDescendants(shadow, oldShadow)
}

// resolveTreeDescendants is other half of resolveTree, building a list of children
// and recursively calling resolveTree for rendered and child nodes. Note that it
// recursively calls _resolveTree_, not itself. The key difference from resolveTree
// is that this function does not attempt to resolve the parent node. This is useful
// when re-entering the tree, like resolveBox does.
func (r *SceneRenderer) resolveTreeDescendants(shadow, oldShadow *shadowNode) shadowNodePairs {
	var unresolvable shadowNodePairs

	if shadow.rendered != nil {
		// When there is a rendered tree (meaning, this node is a Component), any
		// children of this node are reparented to become children of the rendered
		// node. As of now, the rendered node hasn't been resolved yet. We'll
		// pre-populate its shadowChildren with the reparented children, and it can
		// pick those up during its own resolveTree pass.
		//
		// There's no need to handle oldShadow here; the state for these reparented
		// nodes will be under their final parent in the old tree, and it will
		// handle that as usual when it resolves.

		// Create placeholder shadow nodes in rendered for all children
		if pnode, ok := shadow.sceneNode.(sg.Parentable); ok {
			children := pnode.GetChildren()
			shadowChildren := make([]*shadowNode, len(children))
			for index, child := range children {
				shadowChildren[index] = &shadowNode{sceneNode: child}
			}
			shadow.rendered.shadowChildren = append(shadow.rendered.shadowChildren, shadowChildren...)
		}

		// There may also be nodes that were reparented to us; they are forwarded
		// on to this rendered node as well.
		shadow.rendered.shadowChildren = append(shadow.rendered.shadowChildren, shadow.shadowChildren...)
		shadow.shadowChildren = nil

		// Finally, recurse to resolve the rendered tree
		if oldShadow != nil {
			unresolvable = r.resolveTree(shadow.rendered, oldShadow.rendered)
		} else {
			unresolvable = r.resolveTree(shadow.rendered, nil)
		}
	} else if pnode, ok := shadow.sceneNode.(sg.Parentable); ok {
		// If the node is Parentable, recursively resolve all children. If there is an
		// oldShadow, correlate the children with the old shadow tree to preserve state.
		//
		// If this node was the head of a rendered tree, shadowChildren may already have
		// placeholder entries for children that are being reparented here. These are
		// stacked _after_ the native children of this node, but otherwise they are
		// resolved in the same way.

		// Populate shadowChildren with placeholder entries for all children
		{
			children := pnode.GetChildren()
			shadowChildren := make([]*shadowNode, len(children))
			for index, child := range children {
				shadowChildren[index] = &shadowNode{sceneNode: child}
			}
			// Prepend this to anything that is already in shadowChildren
			shadow.shadowChildren = append(shadowChildren, shadow.shadowChildren...)
		}

		// Now iterate the full list of children, copy over any render state (like the
		// transform), and recursively resolve their tree. If there are equivalent
		// nodes in the oldShadow, pass them along to preserve state. They will be
		// type-checked before use in renderNode.
		for index, shadowChild := range shadow.shadowChildren {
			var oldShadowChild *shadowNode
			if oldShadow != nil && len(oldShadow.shadowChildren) > index {
				oldShadowChild = oldShadow.shadowChildren[index]
			}

			shadowChild.transform = shadow.transform

			unresolvable = append(unresolvable, r.resolveTree(shadowChild, oldShadowChild)...)
		}
	}

	return unresolvable
}

// resolveBox executes a Box layout and resolves its subtrees, including any
// child Boxes. Calling resolveBox for a root Box is sufficient to resolve the
// entire scene.
//
// Returns the actual size determined by the box's layout.
func (r *SceneRenderer) resolveBox(shadow, oldShadow *shadowNode, c sg.Constraints) sg.Size {
	box := shadow.sceneNode.(layouts.Box)

	// First, call resolveTreeDescendants for the Box. This will resolve
	// any non-Box subtrees or intermediaries, which can be ignored for
	// layout purposes. The unresolvable list will include any (unresolved)
	// descendant Box nodes, which become the list of children for the layout.
	unresolvable := r.resolveTreeDescendants(shadow, oldShadow)

	// Turn that into a list of Box children, and throw away anything else
	children := make([]layouts.BoxChild, 0, len(unresolvable))
	for _, node := range unresolvable {
		if _, ok := node.Current.sceneNode.(layouts.Box); ok {
			children = append(children, renderBoxChild{r, node.Current, node.Old})
		} else {
			panic(fmt.Sprintf("unknown node %T %+v", node.Current.sceneNode, node.Current.sceneNode))
		}
	}

	// Call layout function; it is responsible for resolving all child boxes
	// if appropriate. It will also use BoxChild.SetPosition to update their
	// position.
	size := box.Layout(c, children, box.Props)

	// Keep the layout's actual size in state for draw
	state, _ := shadow.state.(renderBoxState)
	state.Size = size
	shadow.state = state

	return size
}

// renderBoxState is private state kept by SceneRenderer on Box nodes
type renderBoxState struct {
	Pos  sg.Position
	Size sg.Size
}

// renderBoxChild implements layouts.BoxChild for resolveBox; this exists only
// during the layout function.
type renderBoxChild struct {
	r                 *SceneRenderer
	shadow, oldShadow *shadowNode
}

var _ layouts.BoxChild = renderBoxChild{}

func (rb renderBoxChild) Props() interface{} {
	return rb.shadow.sceneNode.(layouts.Box).ParentProps
}
func (rb renderBoxChild) Render(c sg.Constraints) sg.Size {
	return rb.r.resolveBox(rb.shadow, rb.oldShadow, c)
}
func (rb renderBoxChild) SetPosition(pos sg.Position) {
	state, _ := rb.shadow.state.(renderBoxState)
	state.Pos = pos
	rb.shadow.state = state
}

package private

import (
	"fmt"
	"log"
	"reflect"
	"sync"
	"time"

	"github.com/CrimsonAS/goggle/sg"
	"github.com/CrimsonAS/goggle/sg2"
)

const sceneDebug = true

// DrawableNode contains a primitive node type that is directly drawable by a
// backend, fully resolved and processed in the scenegraph.
type DrawableNode struct {
	// Node is a drawable primitive node from the scene. The node is not
	// automatically copied, so this reference is not safe to keep after the
	// rendering functions return to user code unless explicitly deep copied.
	Node      sg.Node
	Transform sg2.TransformNode
}

// shadowNode is an entry in the shadow tree, generated by SceneRenderer during
// passes over the node tree. The shadow tree has a node for every node in the input
// scene, including rendered trees. The exact structure of the tree may differ slightly.
type shadowNode struct {
	// Original node from the input scene
	sceneNode sg.Node
	// Resolved result of calling Render() on sceneNode, if the sceneNode is a RenderableNode
	rendered *shadowNode
	// Resolved children of the node, if the sceneNode is Parentable. When a RenderableNode
	// returns a non-nil render tree, children of the node will appear under the rendered node
	// instead.
	shadowChildren []*shadowNode
	// Persisted state for the node
	state sg2.StateType
}

type SceneRenderer struct {
	Window          sg.Windowable
	InputHelper     *InputHelper
	DisableParallel bool
	FullSecondPass  bool
	resolveDrawable bool
	resolveInputs   bool

	shadowRoot *shadowNode
}

func (r *SceneRenderer) Render(root sg.Node) []DrawableNode {
	var tmStart, tmPass time.Time
	var dResolve, dEvents, dCompile time.Duration

	// Resolve tree
	r.resolveDrawable = true
	r.resolveInputs = true
	if sceneDebug {
		tmStart = time.Now()
		tmPass = tmStart
		log.Printf("scene: (1/3) resolving tree")
	}
	newShadowRoot := &shadowNode{sceneNode: root}
	log.Printf("PRE-RENDER, tree is: %+v", r.shadowRoot)
	r.resolveTree(newShadowRoot, r.shadowRoot)
	r.shadowRoot = newShadowRoot

	log.Printf("POST-RENDER, tree is: %+v", r.shadowRoot)

	if sceneDebug {
		now := time.Now()
		dCompile = now.Sub(tmPass)
		dTotal := now.Sub(tmStart)
		log.Printf("scene: resolved in %s (resolve/events/compile: %s/%s/%s)", dTotal, dResolve, dEvents, dCompile)
	}
	/*
		drawables := make([]DrawableNode, len(newShadowRoot.DrawableList))
		for i, node := range newShadowRoot.DrawableList {
			drawables[i].Node = node.Node
			drawables[i].Transform = node.Transform
		}
	*/
	return nil /* drawables */
}

// resolveTree populates a shadowNode by recursively resolving the sceneNode it
// represents and any resolved trees or children. When an oldShadow is also provided,
// the new tree is correlated with the old tree to preserve node state.
func (r *SceneRenderer) resolveTree(shadow *shadowNode, oldShadow *shadowNode) {
	node := shadow.sceneNode

	// If the node's actual type is the same as the old tree, we need to preserve state.
	// Only RenderableNodes may have state, but all other nodes have to preserve the
	// tree state for any child RenderableNodes.
	//
	// For any node where we're not preserving state, oldShadow is discarded here.
	if oldShadow != nil && reflect.TypeOf(oldShadow.sceneNode) != reflect.TypeOf(shadow.sceneNode) {
		if sceneDebug {
			log.Printf("Node type changed from '%T' to '%T', discarding subtree state", oldShadow.sceneNode, shadow.sceneNode)
		}
		oldShadow = nil
	}

	if newRenderableNode, ok := node.(sg2.RenderableNode); ok {
		// Copy state from the old shadow tree
		if oldShadow != nil {
			shadow.state = oldShadow.state
		}

		// Render node
		renderedNode := newRenderableNode.Type(newRenderableNode.Props, &shadow.state, r.Window)
		if renderedNode != nil {
			shadow.rendered = &shadowNode{sceneNode: renderedNode}
			if oldShadow != nil {
				r.resolveTree(shadow.rendered, oldShadow.rendered)
			} else {
				r.resolveTree(shadow.rendered, nil)
			}
		}
	} else {
		// ### unnecessary for this pass? or should transform/etc accumulate here?
		switch node.(type) {
		case sg2.TransformNode:
		case sg2.GeometryNode:
		default:
			panic(fmt.Sprintf("unknown node %T %+v", node, node))
		}
	}

	// Recurse to resolve children
	if pnode, ok := node.(sg.Parentable); ok {
		children := pnode.GetChildren()
		shadowChildren := make([]*shadowNode, len(children))
		var oldShadowChildren []*shadowNode

		// If this is a RenderableNode, children of this node are actually under the
		// next non-renderable node in the shadow tree, appended to any children of that
		// node.
		//
		// In this case, the oldShadow tree also needs to compare from the correct offset
		// in the rendered node's shadowChildren.
		parentShadow, oldParentShadow := shadow, oldShadow
		for parentShadow.rendered != nil {
			parentShadow = parentShadow.rendered
			if oldParentShadow != nil {
				oldParentShadow = oldParentShadow.rendered
				// If the rendered nodes are not the same type, discard old state
				if oldParentShadow != nil && reflect.TypeOf(parentShadow.sceneNode) != reflect.TypeOf(oldParentShadow.sceneNode) {
					oldParentShadow = nil
				}
			}
		}

		prefix := len(parentShadow.shadowChildren)
		if oldParentShadow != nil && prefix < len(oldParentShadow.shadowChildren) {
			oldShadowChildren = oldParentShadow.shadowChildren[prefix:]
		}

		var subtreeWg sync.WaitGroup
		for index, child := range children {
			var oldChildShadow *shadowNode
			if index < len(oldShadowChildren) {
				oldChildShadow = oldShadowChildren[index]
			}

			shadowChildren[index] = &shadowNode{sceneNode: child}

			if r.DisableParallel {
				r.resolveTree(shadowChildren[index], oldChildShadow)
			} else {
				subtreeWg.Add(1)
				go func(c, o *shadowNode) {
					defer subtreeWg.Done()
					r.resolveTree(c, o)
				}(shadowChildren[index], oldChildShadow)
			}
		}

		// Wait for subtrees to resolve
		if !r.DisableParallel {
			subtreeWg.Wait()
		}

		// Store list of shadowChildren
		parentShadow.shadowChildren = append(parentShadow.shadowChildren, shadowChildren...)
	}
}

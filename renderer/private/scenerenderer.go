package private

import (
	"fmt"
	"log"
	"reflect"
	"time"

	"github.com/CrimsonAS/goggle/sg"
	"github.com/CrimsonAS/goggle/sg/components"
	"github.com/CrimsonAS/goggle/sg/layouts"
	"github.com/CrimsonAS/goggle/sg/nodes"
)

const sceneDebug = false

// shadowNode is an entry in the shadow tree, generated by SceneRenderer during
// passes over the node tree. The shadow tree has a node for every node in the input
// scene, including rendered trees. The exact structure of the tree may differ slightly.
type shadowNode struct {
	// Original node from the input scene
	sceneNode sg.Node
	// Resolved result of calling Render() on sceneNode, if the sceneNode is a Component
	rendered *shadowNode
	// Resolved children of the node, if the sceneNode is Parentable. When a Component
	// returns a non-nil render tree, children of the node will appear under the rendered node
	// instead.
	shadowChildren []*shadowNode
	// Persisted state for the node
	state components.StateType
}

type SceneRenderer struct {
	Window          sg.Windowable
	InputHelper     *InputHelper
	FullSecondPass  bool
	resolveDrawable bool
	resolveInputs   bool

	shadowRoot *shadowNode
}

func (r *SceneRenderer) Render(root sg.Node) {
	var tmStart, tmPass time.Time
	var dResolve, dEvents, dCompile time.Duration

	// The root of the tree for SceneRenderer must be a Box, defining the
	// constraints for the scene. Generally, this will be provided by the
	// window backend when calling Render.
	_ = root.(layouts.Box)

	// Resolve tree
	r.resolveDrawable = true
	r.resolveInputs = true
	if sceneDebug {
		tmStart = time.Now()
		tmPass = tmStart
		log.Printf("scene: (1/3) resolving tree")
	}
	newShadowRoot := &shadowNode{sceneNode: root}

	const resolveDebug = false // extremely noisy

	if resolveDebug {
		log.Printf("PRE-RENDER, tree is: %+v", r.shadowRoot)
	}

	r.resolveBox(newShadowRoot, r.shadowRoot, sg.Unconstrained())
	r.shadowRoot = newShadowRoot

	if resolveDebug {
		log.Printf("POST-RENDER, tree is: %+v", r.shadowRoot)
	}

	if sceneDebug {
		now := time.Now()
		dCompile = now.Sub(tmPass)
		dTotal := now.Sub(tmStart)
		log.Printf("scene: resolved in %s (resolve/events/compile: %s/%s/%s)", dTotal, dResolve, dEvents, dCompile)
	}
}

type walkState struct {
	Transform sg.Mat4
	Size      sg.Size
	Callback  func(*shadowNode, sg.Mat4, sg.Size)
}

func (r *SceneRenderer) walkTree(shadow *shadowNode, backwards bool, walk walkState) {
	if shadow == nil {
		return
	}

	if box, ok := shadow.sceneNode.(layouts.Box); ok {
		boxGeometry, _ := shadow.state.(sg.Geometry)
		// Box position is in parent Box coordinates. Translate by that first,
		// then apply the box's transform if present.
		if !boxGeometry.Origin.IsOrigin() {
			walk.Transform = walk.Transform.MulM4(sg.Translate2DV2(boxGeometry.Origin.Vec2()))
		}
		if !box.Transform.IsNil() {
			walk.Transform = walk.Transform.MulM4(box.Transform)
		}
		walk.Size = boxGeometry.Size
	}

	if !backwards {
		walk.Callback(shadow, walk.Transform, walk.Size)
		if shadow.rendered != nil {
			r.walkTree(shadow.rendered, backwards, walk)
		}
	}

	for i := 0; i < len(shadow.shadowChildren); i++ {
		var child *shadowNode
		if backwards {
			child = shadow.shadowChildren[len(shadow.shadowChildren)-i-1]
		} else {
			child = shadow.shadowChildren[i]
		}
		r.walkTree(child, backwards, walk)
	}

	if backwards {
		if shadow.rendered != nil {
			r.walkTree(shadow.rendered, backwards, walk)
		}
		walk.Callback(shadow, walk.Transform, walk.Size)
	}
}

// DeliverEvents walks the rendered shadow tree in input order and
// invokes callbacks or updates state in the tree as appropriate.
// DeliverEvents changes state but does not re-render the tree, so
// the shadow tree is considered dirty after calling this function.
func (r *SceneRenderer) DeliverEvents() {
	r.walkTree(r.shadowRoot, true, walkState{
		Transform: sg.NewIdentity(),
		Callback: func(shadow *shadowNode, transform sg.Mat4, size sg.Size) {
			if node, ok := shadow.sceneNode.(nodes.Input); ok {
				state, _ := shadow.state.(*nodes.InputState)
				if state == nil {
					state = &nodes.InputState{}
					shadow.state = state
				}
				r.InputHelper.ProcessPointerEvents(&node, transform, size, state)
			}
		},
	})
	r.InputHelper.EndPointerEvents()
}

// Draw walks the rendered shadow tree in draw order and calls the
// nodeCallback function for each primitive node.
func (r *SceneRenderer) Draw(nodeCallback func(sg.Node, sg.Mat4, sg.Size)) {
	r.walkTree(r.shadowRoot, false, walkState{
		Transform: sg.NewIdentity(),
		Callback: func(shadow *shadowNode, transform sg.Mat4, size sg.Size) {
			switch shadow.sceneNode.(type) {
			case nodes.Rectangle:
			case nodes.Image:
			default:
				return
			}
			nodeCallback(shadow.sceneNode, transform, size)
		},
	})
}

// resolveNode populates a shadowNode by resolving the sceneNode it represents.
// When an oldShadow is also provided, the new tree is correlated with the old
// tree to preserve node state.
//
// resolveNode expects a shadowNode with sceneNode defined, and all other fields
// to have the default value.
//
// resolveNode does not populate the list of child nodes, and does not resolve
// the rendered tree.
//
// Returns true if the node is resolved, or false if the node is unresolvable
// for any reason. These may include errors, unrecognized nodes, or nodes that
// need to be resolved in a different way (e.g. Box).
func (r *SceneRenderer) resolveNode(shadow *shadowNode, oldShadow *shadowNode) bool {
	node := shadow.sceneNode

	// If the node's actual type is the same as the old tree, we need to preserve state.
	// For any node where we're not preserving state, oldShadow is discarded here.
	if oldShadow != nil && reflect.TypeOf(oldShadow.sceneNode) != reflect.TypeOf(shadow.sceneNode) {
		if sceneDebug {
			log.Printf("Node type changed from '%T' to '%T', discarding subtree state", oldShadow.sceneNode, shadow.sceneNode)
		}
		oldShadow = nil
	}

	// Copy state from the old shadow tree
	if oldShadow != nil {
		shadow.state = oldShadow.state
	}

	switch n := node.(type) {
	case components.Component:
		// Render node
		state := components.RenderState{
			Window:    r.Window,
			NodeState: shadow.state,
		}
		renderedNode := n.Type(n.Props, &state)
		shadow.state = state.NodeState

		if renderedNode != nil {
			shadow.rendered = &shadowNode{sceneNode: renderedNode}
		}

	case nodes.Parent:
	case nodes.Rectangle:
	case nodes.Image:
	case nodes.Input:

	// Box layouts are handled by the parent Box, not by resolveNode.
	case layouts.Box:
		return false
	default:
		return false
	}

	return true
}

type shadowNodePairs []struct{ Current, Old *shadowNode }

// resolveTree recursively resolves the node in 'shadow', its rendered tree, and
// its children. If oldShadow is provided, state will be preserved from that tree.
//
// resolveTree returns a list of nodes at any level of the tree which could not
// be resolved. Some of these may indicate errors, but the common case is to return
// a list of Box nodes in need of layout.
func (r *SceneRenderer) resolveTree(shadow *shadowNode, oldShadow *shadowNode) shadowNodePairs {
	// Resolve this node
	if !r.resolveNode(shadow, oldShadow) {
		// Node is unresolvable; return it to build the list of unresolvable nodes.
		//
		// There is no need to keep oldShadow for this list. If there is state to
		// preserve on this node, resolveNode has already done so.
		return shadowNodePairs{{shadow, oldShadow}}
	}

	return r.resolveTreeDescendants(shadow, oldShadow)
}

// resolveTreeDescendants is other half of resolveTree, building a list of children
// and recursively calling resolveTree for rendered and child nodes. Note that it
// recursively calls _resolveTree_, not itself. The key difference from resolveTree
// is that this function does not attempt to resolve the parent node. This is useful
// when re-entering the tree, like resolveBox does.
func (r *SceneRenderer) resolveTreeDescendants(shadow, oldShadow *shadowNode) shadowNodePairs {
	var unresolvable shadowNodePairs

	if shadow.rendered != nil {
		// When there is a rendered tree (meaning, this node is a Component), any
		// children of this node are reparented to become children of the rendered
		// node. As of now, the rendered node hasn't been resolved yet. We'll
		// pre-populate its shadowChildren with the reparented children, and it can
		// pick those up during its own resolveTree pass.
		//
		// There's no need to handle oldShadow here; the state for these reparented
		// nodes will be under their final parent in the old tree, and it will
		// handle that as usual when it resolves.

		// Create placeholder shadow nodes in rendered for all children
		if pnode, ok := shadow.sceneNode.(sg.Parentable); ok {
			children := pnode.GetChildren()
			shadowChildren := make([]*shadowNode, len(children))
			for index, child := range children {
				shadowChildren[index] = &shadowNode{sceneNode: child}
			}
			shadow.rendered.shadowChildren = append(shadow.rendered.shadowChildren, shadowChildren...)
		}

		// There may also be nodes that were reparented to us; they are forwarded
		// on to this rendered node as well.
		shadow.rendered.shadowChildren = append(shadow.rendered.shadowChildren, shadow.shadowChildren...)
		shadow.shadowChildren = nil

		// Finally, recurse to resolve the rendered tree
		if oldShadow != nil {
			unresolvable = r.resolveTree(shadow.rendered, oldShadow.rendered)
		} else {
			unresolvable = r.resolveTree(shadow.rendered, nil)
		}
	} else if pnode, ok := shadow.sceneNode.(sg.Parentable); ok {
		// If the node is Parentable, recursively resolve all children. If there is an
		// oldShadow, correlate the children with the old shadow tree to preserve state.
		//
		// If this node was the head of a rendered tree, shadowChildren may already have
		// placeholder entries for children that are being reparented here. These are
		// stacked _after_ the native children of this node, but otherwise they are
		// resolved in the same way.

		// Populate shadowChildren with placeholder entries for all children
		{
			children := pnode.GetChildren()
			shadowChildren := make([]*shadowNode, len(children))
			for index, child := range children {
				shadowChildren[index] = &shadowNode{sceneNode: child}
			}
			// Prepend this to anything that is already in shadowChildren
			shadow.shadowChildren = append(shadowChildren, shadow.shadowChildren...)
		}

		// Now iterate the full list of children, and recursively resolve their tree.
		// If there are equivalent nodes in the oldShadow, pass them along to preserve
		// state. They will be type-checked before use in renderNode.
		for index, shadowChild := range shadow.shadowChildren {
			var oldShadowChild *shadowNode
			if oldShadow != nil && len(oldShadow.shadowChildren) > index {
				oldShadowChild = oldShadow.shadowChildren[index]
			}

			unresolvable = append(unresolvable, r.resolveTree(shadowChild, oldShadowChild)...)
		}
	}

	return unresolvable
}

// resolveBox executes a Box layout and resolves its subtrees, including any
// child Boxes. Calling resolveBox for a root Box is sufficient to resolve the
// entire scene.
//
// Returns the actual size determined by the box's layout.
func (r *SceneRenderer) resolveBox(shadow, oldShadow *shadowNode, c sg.Constraints) sg.Size {
	box := shadow.sceneNode.(layouts.Box)

	// First, call resolveTreeDescendants for the Box. This will resolve
	// any non-Box subtrees or intermediaries, which can be ignored for
	// layout purposes. The unresolvable list will include any (unresolved)
	// descendant Box nodes, which become the list of children for the layout.
	unresolvable := r.resolveTreeDescendants(shadow, oldShadow)

	// Turn that into a list of Box children, and throw away anything else
	children := make([]layouts.BoxChild, 0, len(unresolvable))
	for _, node := range unresolvable {
		if _, ok := node.Current.sceneNode.(layouts.Box); ok {
			children = append(children, renderBoxChild{r, node.Current, node.Old})
		} else {
			panic(fmt.Sprintf("unknown node %T %+v", node.Current.sceneNode, node.Current.sceneNode))
		}
	}

	// Call layout function; it is responsible for resolving all child boxes
	// if appropriate. It will also use BoxChild.SetPosition to update their
	// position.
	size := box.Layout(c, children, box.Props)

	// Keep the layout's actual size in state for draw
	geometry, _ := shadow.state.(sg.Geometry)
	geometry.Size = size
	shadow.state = geometry

	return size
}

// renderBoxChild implements layouts.BoxChild for resolveBox; this exists only
// during the layout function.
type renderBoxChild struct {
	r                 *SceneRenderer
	shadow, oldShadow *shadowNode
}

var _ layouts.BoxChild = renderBoxChild{}

func (rb renderBoxChild) Props() interface{} {
	return rb.shadow.sceneNode.(layouts.Box).ParentProps
}
func (rb renderBoxChild) Render(c sg.Constraints) sg.Size {
	box := rb.shadow.sceneNode.(layouts.Box)

	hasTransform := !box.Transform.IsNil()
	if hasTransform {
		// ### The correct thing to do here would be adjusting the constraints such
		// that applying the transform to newC.Min or newC.Max gives a result within
		// c.
		//
		// I don't want to think hard enough to calculate that properly right now.
		// As a half-assed attempt, invert the matrix and get the transformed bounds
		// of min and max. This is definitely buggy for some cases.
		var unused bool
		invert := box.Transform.Inverted(&unused)
		c = sg.Constraints{
			Min: sg.Geometry{Size: c.Min}.TransformedBounds(invert).BottomRight().ToSize(),
			Max: sg.Geometry{Size: c.Max}.TransformedBounds(invert).BottomRight().ToSize(),
		}
	}

	// ### Layouts are allowed to Render a child more than once, in case they need to
	// change constraints. Shadow should be cleaned up before doing that -- rendering
	// the same dirty shadow node more than once leads to unspecified chaos.
	//
	// Unfortunately, that isn't as simple as wiping out this shadowNode, because of
	// one critical edge case: if the child Box's parent is a Component, there could
	// be reparented children in the shadowNode before the first render. Those
	// reparented children are also modified by this render, so we actually need an
	// unmodified copy of their original state to proceed.

	size := rb.r.resolveBox(rb.shadow, rb.oldShadow, c)
	if hasTransform {
		// Transform the size before returning to the parent layout. More specifically,
		// find a bounding box of a transformed rectangle of size, and use the distance
		// between the bottom-right corner and origin as the actual size (to include any
		// translation).
		size = sg.Geometry{Size: size}.TransformedBounds(box.Transform).BottomRight().ToSize()
	}
	return size
}

func (rb renderBoxChild) Geometry() sg.Geometry {
	geometry, _ := rb.shadow.state.(sg.Geometry)
	return geometry
}

func (rb renderBoxChild) SetPosition(pos sg.Position) {
	geometry, _ := rb.shadow.state.(sg.Geometry)
	geometry.Origin = pos
	rb.shadow.state = geometry
}
